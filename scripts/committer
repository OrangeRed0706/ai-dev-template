#!/usr/bin/env bash
# scripts/committer - Scoped commit helper
#
# 用法：./scripts/committer "commit message" file1 file2 ...
#
# 這個腳本只會 stage 指定的檔案，避免意外 commit 其他改動。
# 適合多 agent 協作時使用。

set -euo pipefail

usage() {
  printf 'Usage: %s "commit message" "file" ["file" ...]\n' "$(basename "$0")" >&2
  exit 2
}

if [ "$#" -lt 2 ]; then
  usage
fi

commit_message=$1
shift

if [[ "$commit_message" != *[![:space:]]* ]]; then
  printf 'Error: commit message must not be empty\n' >&2
  exit 1
fi

if [ -e "$commit_message" ]; then
  printf 'Error: first argument looks like a file path; provide the commit message first\n' >&2
  exit 1
fi

files=("$@")

# 不允許 "." — 這會 stage 整個 repo
for file in "${files[@]}"; do
  if [ "$file" = "." ]; then
    printf 'Error: "." is not allowed; list specific paths instead\n' >&2
    exit 1
  fi
done

# 不允許 node_modules
for file in "${files[@]}"; do
  case "$file" in
    *node_modules*)
      printf 'Error: node_modules paths are not allowed: %s\n' "$file" >&2
      exit 1
      ;;
  esac
done

# 檢查檔案存在
for file in "${files[@]}"; do
  if [ ! -e "$file" ]; then
    if ! git ls-files --error-unmatch -- "$file" >/dev/null 2>&1; then
      printf 'Error: file not found: %s\n' "$file" >&2
      exit 1
    fi
  fi
done

# 先 unstage 所有，再只 stage 指定的檔案
git restore --staged :/ 2>/dev/null || true
git add --force -- "${files[@]}"

if git diff --staged --quiet; then
  printf 'Warning: no staged changes detected for: %s\n' "${files[*]}" >&2
  exit 1
fi

git commit -m "$commit_message" -- "${files[@]}"

printf 'Committed "%s" with %d files\n' "$commit_message" "${#files[@]}"
